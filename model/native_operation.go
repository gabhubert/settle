package model

import (
	"time"

	"golang.org/x/net/context"

	"github.com/jmoiron/sqlx/types"
	"github.com/spolu/settle/api"
	"github.com/spolu/settle/lib/errors"
	"github.com/spolu/settle/lib/format"
	"github.com/spolu/settle/lib/livemode"
	"github.com/spolu/settle/lib/token"
)

// NativeOperation represents a transaction for a single native operation
// generated by the API based on the parameters passed by the client, ready to
// be signed and submitted.
type NativeOperation struct {
	ID       int64
	Token    string
	Created  time.Time
	Livemode bool

	UserToken    string `db:"user_token"`
	UserUpdateID int64  `db:"user_update_id"`

	Type           string
	Parameters     types.JSONText
	TransactionXDR string `db:"transaction_xdr"`
}

func init() {
	ensureAPIDB()
}

// CreateNativeOperation creates and stores a new NativeOperation.
func CreateNativeOperation(
	ctx context.Context,
	userUpdate *UserUpdate,
	opType api.OpType,
	parameters map[string]string,
	transactionXDR string,
) (*NativeOperation, error) {
	op := NativeOperation{
		Token:          token.New("native_operation"),
		Livemode:       livemode.Get(ctx),
		UserToken:      UserUpdate.UserToken,
		UserUpdateID:   UserUpdate.ID,
		Type:           string(opType),
		Parameters:     format.JSONRaw(parameters),
		TransactionXDR: transactionXDR,
	}

	tx := apidb.MustBegin()
	defer tx.Rollback()

	if rows, err := apidb.NamedQuery(`
INSERT INTO native_operations
  (token, livemode, user_token, user_update_id, type, parameters,
  transaction_xdr)
VALUES
  (:token, :livemode, :user_token, :user_update_id, :type, :parameters,
  :transaction_xdr)
RETURNING id, created
`, op); err != nil {
		return nil, errors.Trace(err)
	} else if !rows.Next() {
		return nil, errors.Newf("Nothing returned from INSERT.")
	} else if err := rows.StructScan(&op); err != nil {
		return nil, errors.Trace(err)
	}

	if err := tx.Commit(); err != nil {
		return nil, errors.Trace(err)
	}

	return &op, nil
}
